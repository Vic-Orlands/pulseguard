// ---
// title: "OpenTelemetry Collector + Loki: From Log Files to Searchable Insights"
// description: "Learn how to transform static log files into a powerful, searchable observability platform using OpenTelemetry Collector and Loki"
// publishedAt: "2025-06-16"
// author: "DevOps Engineer"
// tags: ["OpenTelemetry", "Loki", "Observability", "Logging", "DevOps"]
// category: "Infrastructure"
// ---

// import { CodeBlock } from "@/components/CodeBlock";
// import { ArchitectureDiagram } from "@/components/ArchitectureDiagram";
// import { Callout } from "@/components/Callout";

// # OpenTelemetry Collector + Loki: From Log Files to Searchable Insights

// ## The Bookstore Analogy

// Imagine you own a bookstore with customers constantly coming and going. You diligently write everything in a **logbook**: who entered, what they bought, and if anything went wrong. But this logbook is getting massive, and you need a way to **search, analyze, and understand what's happening** in your store automatically.

// That's exactly where the **OpenTelemetry Collector + Loki setup** comes in. Let's explore how logs move from your logbook (files) to something truly useful.

// ## The Setup Overview

// <Callout type="info">
//   This setup transforms your static log files into a dynamic, searchable
//   observability platform.
// </Callout>

// Here's the architecture we're working with:

// <CodeBlock language="text" title="Data Flow">
//   {`File on Disk (logbook) 
//     ↓ 
// OpenTelemetry Collector 
//     ├── filelog receiver (reads your logs) 
//     ├── processors (can add labels like "project_id") 
//     └── loki exporter (sends logs to Loki) 
//     ↓ 
// Loki (searchable log database)`}
// </CodeBlock>

// ## Step-by-Step Breakdown

// ### 1. Filelog Receiver - "The Logbook Reader"

// Think of this as a librarian who **reads your logbook** (files on your server). It understands how to read each line and recognize the important bits like timestamps, log levels, messages, and trace information.

// <CodeBlock language="yaml" title="Filelog Receiver Configuration">
//   {`filelog:
//   include: ["/app/logs/*.log"]
//   start_at: beginning`}
// </CodeBlock>

// <Callout type="tip">
//   **Translation**: "Start reading from the beginning of these log files and keep
//   monitoring them for new entries."
// </Callout>

// ### 2. Processors - "The Labeling Genius"

// Before the logs reach the archive (Loki), processors act as a middle-person that **adds labels** such as:

// - Project ID
// - Trace ID
// - Service name
// - Environment tags

// <CodeBlock language="yaml" title="Attributes Processor Configuration">
//   {`attributes:
//   actions:
//     - action: insert
//       key: trace_id
//       from_attribute: traceId`}
// </CodeBlock>

// <Callout type="tip">
//   **Translation**: "Attach some metadata to logs so we can filter and search
//   them effectively later."
// </Callout>

// ### 3. Loki Exporter - "The Courier"

// This component takes the processed logs and **delivers them to Loki**, which serves as your searchable database of logs.

// <CodeBlock language="yaml" title="Loki Exporter Configuration">
//   {`exporters:
//   loki:
//     endpoint: http://loki:3100/loki/api/v1/push`}
// </CodeBlock>

// <Callout type="tip">
//   **Translation**: "Ship these logs to the archive room (Loki) so we can find
//   them later."
// </Callout>

// ### 4. Loki - "The Searchable Archive"

// Loki stores all the logs efficiently and lets you search for things like:

// - All errors from today
// - Logs from a specific project
// - Logs tied to a particular trace ID
// - Performance issues in specific services

// ## Visual Architecture

// <ArchitectureDiagram>
//   {`
//  ┌─────────────────────────────┐
//  │     /app/logs/*.log         │
//  │    (Your log files)         │
//  └────────────┬────────────────┘
//               │ Reads
//               ▼
//  ┌─────────────────────────────┐
//  │   filelog receiver          │
//  │   - Parses structured logs  │
//  └────────────┬────────────────┘
//               │ Processes
//               ▼
//  ┌─────────────────────────────┐
//  │  attributes processor       │
//  │  - Adds project_id, trace_id│
//  └────────────┬────────────────┘
//               │ Exports
//               ▼
//  ┌─────────────────────────────┐
//  │    loki exporter            │
//  │    - Push logs to Loki      │
//  └────────────┬────────────────┘
//               │
//               ▼
//  ┌─────────────────────────────┐
//  │        Loki                 │
//  │   - Search & view logs      │
//  └─────────────────────────────┘
// `}
// </ArchitectureDiagram>

// ## Why Choose OpenTelemetry Collector Over Promtail?

// <Callout type="warning">
//   Promtail is like a specialized librarian that **only reads logs and sends them
//   to Loki**. While it's excellent at that job, OpenTelemetry Collector offers a
//   more comprehensive solution.
// </Callout>

// **OpenTelemetry Collector handles:**

// - **Traces** (distributed tracing data)
// - **Metrics** (performance measurements)
// - **Logs** (application logs)

// All in one unified platform. If you're already using OpenTelemetry for observability, using the `filelog` receiver eliminates the need for additional tools and reduces infrastructure complexity.

// ## Key Benefits

// <div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
//   <div className="p-4 border rounded-lg">
//     <h3 className="font-semibold text-blue-600">Centralized Observability</h3>
//     <p>One tool handles all your telemetry data</p>
//   </div>
//   <div className="p-4 border rounded-lg">
//     <h3 className="font-semibold text-green-600">Reduced Complexity</h3>
//     <p>Fewer moving parts in your observability stack</p>
//   </div>
//   <div className="p-4 border rounded-lg">
//     <h3 className="font-semibold text-purple-600">Better Correlation</h3>
//     <p>Easier to connect logs with traces and metrics</p>
//   </div>
//   <div className="p-4 border rounded-lg">
//     <h3 className="font-semibold text-orange-600">Flexible Processing</h3>
//     <p>Rich ecosystem of processors for data transformation</p>
//   </div>
// </div>

// ## Getting Started Checklist

// <div className="space-y-3">
//   <div className="flex items-center space-x-3">
//     <input type="checkbox" className="rounded" />
//     <span>**Configure filelog receiver** to read from your log files</span>
//   </div>
//   <div className="flex items-center space-x-3">
//     <input type="checkbox" className="rounded" />
//     <span>**Set up processors** to add necessary context and labels</span>
//   </div>
//   <div className="flex items-center space-x-3">
//     <input type="checkbox" className="rounded" />
//     <span>**Configure Loki exporter** to send data to your Loki instance</span>
//   </div>
//   <div className="flex items-center space-x-3">
//     <input type="checkbox" className="rounded" />
//     <span>**Connect Grafana** to Loki for visualization and alerting</span>
//   </div>
//   <div className="flex items-center space-x-3">
//     <input type="checkbox" className="rounded" />
//     <span>**Test your setup** with sample queries</span>
//   </div>
// </div>

// ## Recap for Beginners

// <Callout type="success">
//   The OpenTelemetry Collector + Loki setup transforms your static log files into
//   a powerful, searchable observability platform.
// </Callout>

// The key steps are:

// - **Use filelog** to read logs from your files
// - **Add context** (project ID, trace ID, etc.) with processors
// - **Send logs** to Loki using the Loki exporter
// - **Search everything** inside Grafana connected to Loki

// This approach gives you the foundation for effective log management, debugging, and system monitoring at scale.

// ---

// <Callout type="info">
//   *Ready to implement this setup? The next step would be creating a complete
//   working configuration file tailored to your specific environment and
//   requirements.*
// </Callout>

// export default ({ children }) => <article className="prose prose-lg max-w-4xl mx-auto">{children}</article

// >
